"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryExpressionIntrinsics = void 0;
const errors_1 = require("../../errors");
const resolveConstantValue_1 = require("../../types/resolveConstantValue");
const resolveExpression_1 = require("../../types/resolveExpression");
const writeConstant_1 = require("../writers/writeConstant");
function tryExpressionIntrinsics(exp, ctx) {
    // Calls intrinsics
    if (exp.kind === "op_call") {
        const sourceType = (0, resolveExpression_1.getExpType)(ctx.ctx, exp.src);
        if (sourceType.kind === "ref" &&
            sourceType.name === "String" &&
            !sourceType.optional) {
            //
            // Handle String.asComment()
            //
            if (exp.args.length === 0 && exp.name === "asComment") {
                let constString = null;
                // Try to resolve constant value
                try {
                    const res = (0, resolveConstantValue_1.resolveConstantValue)(sourceType, exp.src, ctx.ctx);
                    if (typeof res !== "string") {
                        throw new Error("Expected string");
                    }
                    constString = res;
                }
                catch (e) {
                    // Ignore
                }
                // Render if constant
                if (constString !== null) {
                    const id = (0, writeConstant_1.writeComment)(constString, ctx);
                    ctx.used(id);
                    return `${id}()`;
                }
            }
        }
    }
    try {
        const t = (0, resolveExpression_1.getExpType)(ctx.ctx, exp);
        if (t.kind === "null") {
            const r = (0, resolveConstantValue_1.resolveConstantValue)(t, exp, ctx.ctx);
            if (r !== null) {
                throw new Error("Expected null");
            }
            return "null()";
        }
        if (t.kind === "ref") {
            if (t.name === "Int") {
                const r = (0, resolveConstantValue_1.resolveConstantValue)(t, exp, ctx.ctx);
                if (typeof r !== "bigint") {
                    throw new Error("Expected bigint");
                }
                return r.toString(10);
            }
            if (t.name === "Bool") {
                const r = (0, resolveConstantValue_1.resolveConstantValue)(t, exp, ctx.ctx);
                if (typeof r !== "boolean") {
                    throw new Error("Expected boolean");
                }
                return r ? "true" : "false";
            }
        }
    }
    catch (e) {
        if (e instanceof errors_1.TactSyntaxError) {
            if (!e.message.includes("Cannot reduce expression to a constant") &&
                !e.message.includes("Expected constant value")) {
                throw e;
            }
        }
    }
    return null;
}
exports.tryExpressionIntrinsics = tryExpressionIntrinsics;
